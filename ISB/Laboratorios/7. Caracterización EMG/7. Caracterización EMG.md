 # Laboratorio 7: Caracterización del EMG.
## Tabla de contenidos:
* [Objetivos](#objetivos)
* [Filtros : IIR ,FIR O WAVELET](#filtro)
* [Entregables](#entregable)
 
  * [Filtrado de señal EMG ](#emg)
  * [Explicación de los filtros de señales EMG](#explicación-emg)
  * [Caracterizacoón del EMG ](#ecg)

 
* [Bibliografía](#bibliografía)
 
## Objetivos:

* Adquirir señales biomédicas de EMG .
* Aplicar filtro a la señal EMG.
* Extraer la información de las carácteristicas principales de una señal EMG .


## Adquisición de la señal EMG
Utilizamos la señal electromiográfica de la participante 1que realiza ejercicios del biceps con una carga determinada durante 5 segundos, luego reposa durante  5 segundos y repite el ciclo durante 30 segundos.



```
f = open("Nataly.txt","r")
raw_data = f.read()  # con f.read() leemos todo el contenido
f.close()


raw_data
Fs = 1000
Ts = 1/Fs
print(f" Fs={Fs} hz\n Ts={Ts} s")

f = open("Nataly.txt","r")
raw_data = f.read()  # con f.read() leemos todo el contenido
f.close()

raw_data
Fs = 1000
Ts = 1/Fs
print(f" Fs={Fs} hz\n Ts={Ts} s")

a = np.genfromtxt("./ecg1reposo.txt", delimiter="\t",skip_header = 3)
yarray = a[:, 5]
N=len(yarray)
bits = 10 # Bits de la salida
volt_range = 3.3
yarray = (yarray/2**bits -1/2) * volt_range/1009
yarray=yarray*1000 # convertir los bits a mV
yarray = yarray - np.mean(yarray)
xarray = np.arange(1, len(yarray)+1)/Fs
xarray=xarray
plt.figure(figsize=(8, 6))
plt.plot(xarray, yarray, label="señal")
plt.grid(linestyle=":")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud en mV")
plt.legend(loc="upper right")

```

Analizamos durante 50 segundos y un rango de 13-13.25 segundos para visualizar de mejor manera el filtro (plt.xlim(13, 13.25)). 


![fft](https://github.com/arianacarbajal/ISB_Grupo3/blob/c3d3ffba7801d64d2c287300ce8f0d2b63407229/ISB/Laboratorios/Imagenes/Se%C3%B1al%20ORIGINAL.png)
Señal original 

![fft](https://github.com/arianacarbajal/ISB_Grupo3/blob/c7828602164a3d10b6a0c213ff44c8a9cda443d2/ISB/Laboratorios/Imagenes/se%C3%B1al-rango13-13.25.png)
Señal original shifteada en 13-13.25 segundos 

Aqui mostramos el FFT de la señal EMG:

![fft](https://github.com/arianacarbajal/ISB_Grupo3/blob/e60a80461ae7f156b3369c182fb33d2e5240ed26/Imagen/FFT-NORMALIZADA%20SE%C3%91AL.png)




## Filtrado de la señal EMG-Filtro (IIR )


se realiza un filtro IIR  con una frecuencia de corte baja  de 10 hz  y frecuencia de corte alta de 200 hz. Esto se verifica ya que la literatura nos indica que solo en este rango, se puede filtrar el ruido de la señal EMG sin afectar sus carácterísticas importantes como amplitud,RMS ,frecuencia máxima, entre otras. Además, se hace un iinotch en la frecuencia de 60 hz que es la que genera más ruido.


```
Diseño del FILTRO IIR :

pre_pro_signal= yarray-np.average(yarray)

low_cutoff=10
high_cutoff=200

signal_filt=butter_bandpass_filter(pre_pro_signal,low_cutoff,high_cutoff,order=4,fs=1000)


b,c=iirnotch(60,30,Fs)

signal_filtrada=filtfilt(b,c,signal_filt)


plt.figure()
plt.plot(xarray,signal_filtrada, label="señal filtrada")
plt.grid(linestyle=":")
plt.xlabel("Tiempo (s)")
#plt.xlim("Tiempo (s)")
plt.ylabel("Amplitud en mV")
plt.legend(loc="upper right")
plt.title("Filtro IIR-BANDPASS")
plt.xlim(13, 13.25)


# Calcular la FFT de la señal filtrada IIR
sig_fft1 = np.fft.fft(signal_filtrada)
frequencies = np.fft.fftfreq(N, Ts)

# Reorganizar las frecuencias para que estén en el rango de -Fs/2 a Fs/2
frequencies = np.fft.fftshift(frequencies)
sig_fftq = np.fft.fftshift(sig_fft1)

#Vector de frecuencias.
tam=len(np.abs(signal_fft))
print(f" Fs={len(np.abs(signal_fft))} hz\n Ts={Ts} s")
#frecuencias
F1 = np.linspace(0, Fs/2, tam)


# Graficar la FFT normalizada
plt.figure(figsize=(8, 6))
plt.plot(F1,np.abs(sig_fftq), label="FFT Normalizada  bandpass")
plt.grid(linestyle=":")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Amplitud")
plt.legend(loc="upper right")
plt.xlim(0, Fs/2)  # Limitar el rango de frecuencias de 0 a Fs/2 Hz en la gráfica

```



![fft](https://github.com/arianacarbajal/ISB_Grupo3/blob/e117567cde5080408137a25f9ccfc0f46da18008/ISB/Laboratorios/Imagenes/FILTRADO%20IIR-BANDPASS.png)

Señal filtrada shifteada en 13-13.25 segundos 

![fft](https://github.com/arianacarbajal/ISB_Grupo3/blob/833ffe31237fa554fee5212bac92e541f4ddcd52/Imagen/FFT-NORMALIZADA%20BANDPASS.png)

FFT de la Señal filtrada.


## Caracterización de EMG:

Caracterizamos la señal EMG para obtener los valores característicos de esta señal, como RMS, max amplitud, min amplitud, entre otros. Para esto, utilizamos la funcion extract_features que nos permitirá encontrar los valores que requerimos hallar.


```
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import re
from scipy import integrate

from scipy.integrate import cumtrapz
from scipy.stats import linregress
from scipy.signal import firwin, lfilter,butter,iirnotch,find_peaks,filtfilt,hilbert,welch
from tqdm import tqdm
import pywt



def extract_features(signal):

  mean=np.mean(signal)
  std=np.std(signal)
  amplitude=np.max(signal)-np.min(signal)
  fft_signal=np.fft.fft(signal)
  dominant_frecuency=np.argmax(np.abs(fft_signal))
  peaks,a =find_peaks(signal)
  duration=(peaks[-1]-peaks[0])/len(signal)
  power=np.sum(np.square(signal))/len(signal)
  kurtosis=np.sum((signal-mean)**4)/(len(signal)*std**4)
  coeffs=pywt.wavedec(signal,'db4',level=5)
  cA5,cD5,cD4,cD3,cD2,cD1=coeffs
  wavelet=np.concatenate((cD1,cD2,cD3,cD4,cD5))
  rms=np.sqrt(np.sum(signal*signal)/len(signal))
  area=cumtrapz(signal)
  f,P=welch(signal,fs=1000,window='hann',noverlap=0,nfft=int(256.))
  area_freq=cumtrapz(P,f,initial=0)
  total_power=area_freq[-1]
  median_freq=f[np.where(area_freq>total_power/2)[0][0]]
  f_max=f[np.argmax(P)]
  features={'media': mean,
            'desviacion_estándar':std,
            'amplitud':amplitude,
            'duration of muscular contraccion':duration,
            'frecuencia dominante':dominant_frecuency,
            'potencia':power,
            'kurtosis':kurtosis,
            'wavelet':wavelet,
            'rms':rms,
            'area':area,
            'min_value':np.min(signal),
            'max_value':np.max(signal),
            'area_freq':area_freq,
            'total_power':total_power,
            'median_freq':median_freq,
            'f_max':f_max

             }
  return features

extract_features(yarray) # Yarray es la señal original.

%Caracteristicas extraidas

{'media': 1.9059419762468076e-18,
 'desviacion_estándar': 0.1037660769829512,
 'amplitud': 2.6605279051040633,
 'duration of muscular contraccion': 0.9998935037273695,
 'frecuencia dominante': 44133,
 'potencia': 0.010767398732431755,
 'kurtosis': 43.03931909580141,
 'wavelet': array([ 4.49437397e-05, -3.19412071e-03, -1.08047692e-02, ...,
        -2.75554168e-02, -8.95167076e-02,  1.26079877e-02]),
 'rms': 0.1037660769829512,
 'area': array([0.00644075, 0.01447845, 0.02251615, ..., 0.05573467, 0.04141499,
        0.01431967]),
 'min_value': -1.015610788348157,
 'max_value': 1.6449171167559062,
 'area_freq': array([0.        , 0.00020211, 0.00054108, 0.0008268 , 0.00105408,
        0.00122879, 0.00135444, 0.00147938, 0.00165748, 0.00185704,
        0.0020771 , 0.00240802, 0.00295716, 0.00381163, 0.00475498,
        0.00548745, 0.00606099, 0.00659897, 0.00714717, 0.00766756,
        0.00806356, 0.00841288, 0.00877993, 0.00910239, 0.00942302,
        0.0097181 , 0.00990999, 0.01002221, 0.01010008, 0.01017673,
        0.01026595, 0.01037237, 0.01045532, 0.01050844, 0.01056199,
        0.01061313, 0.01065349, 0.0106861 , 0.0107174 , 0.01075306,
        0.01078733, 0.01081394, 0.01083886, 0.01086508, 0.01088824,
        0.01090894, 0.01092775, 0.01094348, 0.01096178, 0.01098165,
        0.01099716, 0.01101017, 0.01102168, 0.01103202, 0.01104638,
        0.01106722, 0.0110856 , 0.01110002, 0.01111435, 0.01112715,
        0.01113744, 0.01114639, 0.01115517, 0.01116461, 0.01117316,
        0.01117989, 0.01118647, 0.01119347, 0.01119972, 0.01120473,
        0.0112097 , 0.01121426, 0.01121801, 0.01122136, 0.01122454,
        0.01122798, 0.01123154, 0.01123509, 0.01123807, 0.01124038,
        0.01124262, 0.01124471, 0.01124683, 0.01124906, 0.01125102,
        0.01125265, 0.01125417, 0.01125578, 0.01125728, 0.01125869,
        0.01126024, 0.01126172, 0.01126318, 0.01126451, 0.01126578,
        0.01126714, 0.01126832, 0.01126934, 0.01127045, 0.01127165,
        0.01127275, 0.01127363, 0.0112744 , 0.01127521, 0.01127608,
        0.01127695, 0.0112778 , 0.01127867, 0.01127953, 0.0112802 ,
        0.01128081, 0.01128159, 0.01128229, 0.01128293, 0.01128368,
        0.01128437, 0.01128493, 0.01128545, 0.01128596, 0.01128651,
        0.0112871 , 0.01128771, 0.01128827, 0.01128878, 0.01128933,
        0.01128991, 0.01129045, 0.01129098, 0.01129143]),
 'total_power': 0.011291430294433375,
 'median_freq': 62.5,
 'f_max': 50.78125}
```
### Archivos 
Por otro lado podemos encontrar los archivos de la informacion de las señales ploteadas 

-[Archivos txt de cada señal elegida](https://github.com/arianacarbajal/ISB_Grupo3/tree/d909b519ee5c547a1c889af40f01fbb1b80932ce/ISB/Laboratorios/4.Adquisicion_ECG/Txt_ecg)

-[Archivos ipny con código para tipo señal](https://github.com/arianacarbajal/ISB_Grupo3/tree/d909b519ee5c547a1c889af40f01fbb1b80932ce/ISB/Laboratorios/4.Adquisicion_ECG/Ipny_ecg)

### Codigo utilizado para los graficos en Phyton
El código contiene comentarios para el mejor entendimiento de la lógica usada.


```
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import re
from scipy import signal
from scipy.signal import medfilt, iirnotch, butter, filtfilt


f = open("ecg1reposo.txt","r")
raw_data = f.read()  # con f.read() leemos todo el contenido
f.close()

raw_data
Fs = 1000
Ts = 1/Fs
print(f" Fs={Fs} hz\n Ts={Ts} s")

a = np.genfromtxt("./ecg1reposo.txt", delimiter="\t",skip_header = 3)
yarray = a[:, 5]
N=len(yarray)
bits = 10 # Bits de la salida
volt_range = 3.3
yarray = (yarray/2**bits -1/2) * volt_range/1009
yarray=yarray*1000 # convertir los bits a mV
yarray = yarray - np.mean(yarray)
xarray = np.arange(1, len(yarray)+1)/Fs
xarray=xarray
plt.figure(figsize=(8, 6))
plt.plot(xarray, yarray, label="señal")
plt.grid(linestyle=":")
plt.figure(figsize=(8, 6))
plt.plot(xarray, yarray, label="señal")
plt.grid(linestyle=":")
plt.xlim(0,3)
#FFT
signal_fft = np.fft.fft(yarray)
frequencies = np.fft.fftfreq(N, Ts)

#-Fs/2 a Fs/2
frequencies = np.fft.fftshift(frequencies)
signal_fft = np.fft.fftshift(signal_fft)
plt.figure(figsize=(8, 6))
plt.plot(frequencies, np.abs(signal_fft), label="FFT Normalizada")
plt.grid(linestyle=":")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Amplitud")
plt.legend(loc="upper right")
plt.xlim(0, Fs/2)

plt.figure()
plt.plot(frequencies, 20*np.log10(np.abs(signal_fft)), label="FFT Normalizada en dB")
plt.grid(linestyle=":")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Amplitud")
plt.legend(loc="upper right")
plt.xlim(0, Fs/2)
#Filtro notch
f0 = 60.0
cutoff_freq = 20.0
filter_order = 2
#Filtro pasa baja
normal_cutoff = cutoff_freq / (0.5 * Fs)
b, a = signal.butter(filter_order, normal_cutoff, btype='low', analog=False)
filtered_signal = signal.lfilter(b, a, yarray)
#Filtro pasa alta
filter_order = 30
cutoff_freq = 0.5
normal_cutoff = cutoff_freq / (0.5 * Fs)
b, a = signal.butter(filter_order, normal_cutoff, btype='high', analog=False)


b, a = signal.iirnotch(f0, 30, Fs)
filtered_signal = signal.lfilter(b, a, filtered_signal)

window_size = 13
filtered_signal = medfilt(filtered_signal, kernel_size=window_size)

plt.figure(figsize=(8, 6))
plt.plot(xarray, filtered_signal)
plt.title("Señal filtrada")
plt.grid(linestyle=":")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")
plt.xlim(0,3)

#BPM
threshold = -0.2
above_threshold = np.where(filtered_signal[0:3000] < threshold)[0]
new_array = []
for i in range(len(above_threshold)):
  if i == 0 or above_threshold[i] != above_threshold[i - 1] + 1:
    new_array.append(above_threshold[i])
num_beats = len(new_array)
bpm = (num_beats / 3.0) * 60.0
print("Frecuencia cardíaca: {:.2f} bpm".format(bpm))


signal_fft = np.fft.fft(filtered_signal)
frequencies = np.fft.fftfreq(N, Ts)
frequencies = np.fft.fftshift(frequencies)
signal_fft = np.fft.fftshift(signal_fft)
plt.figure(figsize=(8, 6))
plt.plot(frequencies, np.abs(signal_fft), label="FFT Normalizada")
plt.grid(linestyle=":")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Amplitud")
plt.legend(loc="upper right")
plt.xlim(0, Fs/2)

plt.figure()
plt.plot(frequencies, 20*np.log10(np.abs(signal_fft)), label="FFT Normalizada en dB")
plt.grid(linestyle=":")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Amplitud")
plt.legend(loc="upper right")
plt.xlim(0, Fs/2)

```


### Archivos 
Por otro lado podemos encontrar los archivos de la informacion de las señales ploteadas 

-[Archivos txt de cada señal elegida](https://github.com/arianacarbajal/ISB_Grupo3/tree/c40a2ac86eaf922c38711a895c89a1494187b993/ISB/Laboratorios/7.%20Caracterizaci%C3%B3n%20EMG/txt)

-[Archivos ipny con código para tipo señal](https://github.com/arianacarbajal/ISB_Grupo3/tree/15ac1b547d4aeb2df538cf46f04d6e404d1df8d2/ISB/Laboratorios/7.%20Caracterizaci%C3%B3n%20EMG/ipny)



‌

SEÑALES EN INTERFAZ DE ULTRACORTEX
| Imagen 1 | Imagen 2 | Imagen 3 | Imagen 4 |
|----------|----------|----------|----------|
| ![Imagen 1](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/fa549909-31b4-4690-a0b9-541202d448e5) | ![Imagen 2](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/2939138d-a0e0-46f4-a3bd-9661c2010eba) | ![Imagen 3](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/928f9e72-7435-4e6f-bf00-585df693fd64) | ![Imagen 4](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/fd07dce0-2437-4ff5-bc3e-0587cb9fc34c) |
| ![Imagen 5](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/86d8747c-3571-467b-9ba8-63dcf94eae99) | ![Imagen 6](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/b6851cb1-533e-4c0f-b494-b66be33111df) | ![Imagen 7](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/f4c61204-d5a4-4d68-aafb-b3e04556cd1d) | ![Imagen 8](https://github.com/arianacarbajal/ISB_Grupo3/assets/89601813/db1c14dc-2143-4d97-bdc0-a3082cbcd997) |


## Bibliografía


[1] M. Martínez and G. Trout, “Conceptos Básicos de Electroencefalografía,” Dialnet, https://dialnet.unirioja.es/descarga/articulo/4788132.pdf (accessed Oct. 1, 2023). 

[2] L. J. Gómez Figueroa, “Análisis de señales EEG Para detección de Eventos OCULARES, musculares Y Cognitivos,” Inicio, https://oa.upm.es/44379/ (accessed Oct. 1, 2023). 

[3]“BITalino Lab Guides (Home Guides) – Support PLUX Biosignals official”. Support PLUX Biosignals official – Official PLUX support and biosignals knowledge base. Accedido el 1 de octubre de 2023. [En línea]. Disponible: https://support.pluxbiosignals.com/knowledge-base/bitalino-lab-guides/

[4] R. Sepúlveda, O. Montiel, G. Díaz, D. Gutierrez, and O. Castillo, “Clasificación de Señales Encefalográficas Mediante redes Neuronales Artificiales,” Computación y Sistemas, https://paperity.org/p/190632341/clasificacion-de-senales-encefalograficas-mediante-redes-neuronales-artificiales (accessed Oct. 1, 2023). 

[5] R. Cerino, D. Pinto, S. Vergara, and F. Pérez-Téllez, “Estimulación Visual Basada en conceptos y su análisis mediante electroencefalografía,” SciELO, https://www.scielo.org.mx/scielo.php?script=sci_arttext&pid=S1405-55462023000100107 (accessed Oct. 1, 2023). 

[6] F. Vasconcellos, “Procesamiento de señales EEG Basado en Python - UMH,” UNIVERSIDAD MIGUEL HERNÁNDEZ DE ELCHE ESCUELA POLITÉCNICA SUPERIOR DE ELCHE, http://dspace.umh.es/bitstream/11000/26575/1/TFGVasconcellos%20Noailles%2c%20Fernando.pdf (accessed Oct. 2, 2023). 


[7]Aguilera, P., Beeta, D., Sarmiento, A., & Fondón, I. Cancelación de interferencias en eeg mediante el análisis de componentes acotadas,Universidad de Sevilla, Sevilla, España, Accedido el 1 de octubre de 2023. [En línea]. Disponible:https://www.researchgate.net/profile/Pablo-Aguilera-6/publication/266896121_Cancelacion_de_interferencias_en_EEG_mediante_el_Analisis_de_Componentes_Acotadas/links/547f05490cf2c1e3d2dc392e/Cancelacion-de-interferencias-en-EEG-mediante-el-Analisis-de-Componentes-Acotadas.pdf

